#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "issuerCount" "admin" "i" 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/CardlessIssuer/contract.algo.ts:25
    // issuerCount = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "issuerCount"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/CardlessIssuer/contract.algo.ts:17
    // export class CardlessIssuer extends Contract {
    txn NumAppArgs
    bz main_after_if_else@14
    pushbytess 0xb8447b36 0x272ac801 0x3dd83a3f 0x656971ee 0xa108f335 0x01b81bca // method "createApplication()void", method "addIssuer(account,string,string)void", method "removeIssuer(account)void", method "isAuthorized(account)bool", method "getIssuerInfo(account)(bool,string,string,uint64)", method "transferAdmin(account)void"
    txna ApplicationArgs 0
    match main_createApplication_route@5 main_addIssuer_route@6 main_removeIssuer_route@7 main_isAuthorized_route@8 main_getIssuerInfo_route@9 main_transferAdmin_route@10

main_after_if_else@14:
    // smart_contracts/CardlessIssuer/contract.algo.ts:17
    // export class CardlessIssuer extends Contract {
    intc_0 // 0
    return

main_transferAdmin_route@10:
    // smart_contracts/CardlessIssuer/contract.algo.ts:105
    // transferAdmin(newAdmin: Account): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/CardlessIssuer/contract.algo.ts:17
    // export class CardlessIssuer extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/CardlessIssuer/contract.algo.ts:105
    // transferAdmin(newAdmin: Account): void {
    callsub transferAdmin
    intc_1 // 1
    return

main_getIssuerInfo_route@9:
    // smart_contracts/CardlessIssuer/contract.algo.ts:96
    // getIssuerInfo(issuerAddress: Account): IssuerInfo {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/CardlessIssuer/contract.algo.ts:17
    // export class CardlessIssuer extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/CardlessIssuer/contract.algo.ts:96
    // getIssuerInfo(issuerAddress: Account): IssuerInfo {
    callsub getIssuerInfo
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isAuthorized_route@8:
    // smart_contracts/CardlessIssuer/contract.algo.ts:84
    // isAuthorized(issuerAddress: Account): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/CardlessIssuer/contract.algo.ts:17
    // export class CardlessIssuer extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/CardlessIssuer/contract.algo.ts:84
    // isAuthorized(issuerAddress: Account): boolean {
    callsub isAuthorized
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_removeIssuer_route@7:
    // smart_contracts/CardlessIssuer/contract.algo.ts:63
    // removeIssuer(issuerAddress: Account): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/CardlessIssuer/contract.algo.ts:17
    // export class CardlessIssuer extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/CardlessIssuer/contract.algo.ts:63
    // removeIssuer(issuerAddress: Account): void {
    callsub removeIssuer
    intc_1 // 1
    return

main_addIssuer_route@6:
    // smart_contracts/CardlessIssuer/contract.algo.ts:40
    // addIssuer(issuerAddress: Account, name: string, url: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/CardlessIssuer/contract.algo.ts:17
    // export class CardlessIssuer extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/CardlessIssuer/contract.algo.ts:40
    // addIssuer(issuerAddress: Account, name: string, url: string): void {
    callsub addIssuer
    intc_1 // 1
    return

main_createApplication_route@5:
    // smart_contracts/CardlessIssuer/contract.algo.ts:30
    // createApplication(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/CardlessIssuer/contract.algo.ts::CardlessIssuer.createApplication() -> void:
createApplication:
    // smart_contracts/CardlessIssuer/contract.algo.ts:19
    // name = GlobalState<arc4.Str>()
    pushbytess "name" 0x001b436172646c65737320494420497373756572205265676973747279 // "name", 0x001b436172646c65737320494420497373756572205265676973747279
    // smart_contracts/CardlessIssuer/contract.algo.ts:31
    // this.name.value = new arc4.Str('Cardless ID Issuer Registry')
    app_global_put
    // smart_contracts/CardlessIssuer/contract.algo.ts:22
    // admin = GlobalState<Account>()
    bytec_1 // "admin"
    // smart_contracts/CardlessIssuer/contract.algo.ts:32
    // this.admin.value = Txn.sender
    txn Sender
    app_global_put
    retsub


// smart_contracts/CardlessIssuer/contract.algo.ts::CardlessIssuer.addIssuer(issuerAddress: bytes, name: bytes, url: bytes) -> void:
addIssuer:
    // smart_contracts/CardlessIssuer/contract.algo.ts:40
    // addIssuer(issuerAddress: Account, name: string, url: string): void {
    proto 3 0
    // smart_contracts/CardlessIssuer/contract.algo.ts:42
    // assert(Txn.sender === this.admin.value, 'Only admin can add issuers')
    txn Sender
    // smart_contracts/CardlessIssuer/contract.algo.ts:22
    // admin = GlobalState<Account>()
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/CardlessIssuer/contract.algo.ts:42
    // assert(Txn.sender === this.admin.value, 'Only admin can add issuers')
    ==
    assert // Only admin can add issuers
    // smart_contracts/CardlessIssuer/contract.algo.ts:113
    // issuers = BoxMap<Account, IssuerInfo>({ keyPrefix: 'i' })
    bytec_2 // "i"
    frame_dig -3
    concat
    // smart_contracts/CardlessIssuer/contract.algo.ts:45
    // assert(!this.issuers(issuerAddress).exists, 'Issuer already exists')
    dup
    box_len
    bury 1
    !
    assert // Issuer already exists
    // smart_contracts/CardlessIssuer/contract.algo.ts:50
    // name: new arc4.Str(name),
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/CardlessIssuer/contract.algo.ts:51
    // url: new arc4.Str(url),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/CardlessIssuer/contract.algo.ts:52
    // addedAt: new arc4.UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/CardlessIssuer/contract.algo.ts:48-53
    // this.issuers(issuerAddress).value = new IssuerInfo({
    //   isActive: new arc4.Bool(true),
    //   name: new arc4.Str(name),
    //   url: new arc4.Str(url),
    //   addedAt: new arc4.UintN64(Global.latestTimestamp),
    // }).copy()
    dig 2
    len
    pushint 13 // 13
    +
    itob
    extract 6 2
    pushbytes 0x80000d
    swap
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/CardlessIssuer/contract.algo.ts:25
    // issuerCount = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "issuerCount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/CardlessIssuer/contract.algo.ts:56
    // this.issuerCount.value = this.issuerCount.value + 1
    intc_1 // 1
    +
    // smart_contracts/CardlessIssuer/contract.algo.ts:25
    // issuerCount = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "issuerCount"
    // smart_contracts/CardlessIssuer/contract.algo.ts:56
    // this.issuerCount.value = this.issuerCount.value + 1
    swap
    app_global_put
    retsub


// smart_contracts/CardlessIssuer/contract.algo.ts::CardlessIssuer.removeIssuer(issuerAddress: bytes) -> void:
removeIssuer:
    // smart_contracts/CardlessIssuer/contract.algo.ts:63
    // removeIssuer(issuerAddress: Account): void {
    proto 1 0
    // smart_contracts/CardlessIssuer/contract.algo.ts:65
    // assert(Txn.sender === this.admin.value, 'Only admin can remove issuers')
    txn Sender
    // smart_contracts/CardlessIssuer/contract.algo.ts:22
    // admin = GlobalState<Account>()
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/CardlessIssuer/contract.algo.ts:65
    // assert(Txn.sender === this.admin.value, 'Only admin can remove issuers')
    ==
    assert // Only admin can remove issuers
    // smart_contracts/CardlessIssuer/contract.algo.ts:113
    // issuers = BoxMap<Account, IssuerInfo>({ keyPrefix: 'i' })
    bytec_2 // "i"
    frame_dig -1
    concat
    // smart_contracts/CardlessIssuer/contract.algo.ts:68
    // assert(this.issuers(issuerAddress).exists, 'Issuer does not exist')
    dup
    box_len
    bury 1
    assert // Issuer does not exist
    // smart_contracts/CardlessIssuer/contract.algo.ts:71
    // const issuerInfo = this.issuers(issuerAddress).value.copy()
    dup
    box_get
    assert // Box must have value
    // smart_contracts/CardlessIssuer/contract.algo.ts:72
    // issuerInfo.isActive = new arc4.Bool(false)
    intc_0 // 0
    dup
    setbit
    // smart_contracts/CardlessIssuer/contract.algo.ts:73
    // this.issuers(issuerAddress).value = issuerInfo.copy()
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/CardlessIssuer/contract.algo.ts:25
    // issuerCount = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "issuerCount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/CardlessIssuer/contract.algo.ts:76
    // this.issuerCount.value = this.issuerCount.value - 1
    intc_1 // 1
    -
    // smart_contracts/CardlessIssuer/contract.algo.ts:25
    // issuerCount = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "issuerCount"
    // smart_contracts/CardlessIssuer/contract.algo.ts:76
    // this.issuerCount.value = this.issuerCount.value - 1
    swap
    app_global_put
    retsub


// smart_contracts/CardlessIssuer/contract.algo.ts::CardlessIssuer.isAuthorized(issuerAddress: bytes) -> uint64:
isAuthorized:
    // smart_contracts/CardlessIssuer/contract.algo.ts:84
    // isAuthorized(issuerAddress: Account): boolean {
    proto 1 1
    // smart_contracts/CardlessIssuer/contract.algo.ts:113
    // issuers = BoxMap<Account, IssuerInfo>({ keyPrefix: 'i' })
    bytec_2 // "i"
    frame_dig -1
    concat
    dup
    // smart_contracts/CardlessIssuer/contract.algo.ts:85
    // if (!this.issuers(issuerAddress).exists) {
    box_len
    bury 1
    bnz isAuthorized_after_if_else@2
    // smart_contracts/CardlessIssuer/contract.algo.ts:86
    // return false
    intc_0 // 0
    swap
    retsub

isAuthorized_after_if_else@2:
    // smart_contracts/CardlessIssuer/contract.algo.ts:88
    // return this.issuers(issuerAddress).value.isActive.native
    frame_dig 0
    box_get
    assert // Box must have value
    intc_0 // 0
    getbit
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    retsub


// smart_contracts/CardlessIssuer/contract.algo.ts::CardlessIssuer.getIssuerInfo(issuerAddress: bytes) -> bytes:
getIssuerInfo:
    // smart_contracts/CardlessIssuer/contract.algo.ts:96
    // getIssuerInfo(issuerAddress: Account): IssuerInfo {
    proto 1 1
    // smart_contracts/CardlessIssuer/contract.algo.ts:113
    // issuers = BoxMap<Account, IssuerInfo>({ keyPrefix: 'i' })
    bytec_2 // "i"
    frame_dig -1
    concat
    // smart_contracts/CardlessIssuer/contract.algo.ts:97
    // assert(this.issuers(issuerAddress).exists, 'Issuer not found')
    dup
    box_len
    bury 1
    assert // Issuer not found
    // smart_contracts/CardlessIssuer/contract.algo.ts:98
    // return this.issuers(issuerAddress).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/CardlessIssuer/contract.algo.ts::CardlessIssuer.transferAdmin(newAdmin: bytes) -> void:
transferAdmin:
    // smart_contracts/CardlessIssuer/contract.algo.ts:105
    // transferAdmin(newAdmin: Account): void {
    proto 1 0
    // smart_contracts/CardlessIssuer/contract.algo.ts:106
    // assert(Txn.sender === this.admin.value, 'Only admin can transfer admin rights')
    txn Sender
    // smart_contracts/CardlessIssuer/contract.algo.ts:22
    // admin = GlobalState<Account>()
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/CardlessIssuer/contract.algo.ts:106
    // assert(Txn.sender === this.admin.value, 'Only admin can transfer admin rights')
    ==
    assert // Only admin can transfer admin rights
    // smart_contracts/CardlessIssuer/contract.algo.ts:22
    // admin = GlobalState<Account>()
    bytec_1 // "admin"
    // smart_contracts/CardlessIssuer/contract.algo.ts:107
    // this.admin.value = newAdmin
    frame_dig -1
    app_global_put
    retsub
